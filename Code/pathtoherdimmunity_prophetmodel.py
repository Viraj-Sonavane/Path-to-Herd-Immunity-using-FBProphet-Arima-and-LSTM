# -*- coding: utf-8 -*-
"""PathToHerdImmunity_ProphetModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yCK99zjZ0sEm-_s80p5oM2xuAq9YeZGW

Team Members: 
1. Jayarani Emekar
2. Monika Gadage
3. Viraj Sonawane

Date - 15 May 2021
Enviorment Developed : Google colab

Major References- sklearn lectures, prophet model tutorials, muller book, owid repo

# Path To Herd Immunity -Covid 19 Prediction using Prophet
1. Data Source from OUR WORLD in Data GitHub repository.
2. Goal to predict COVID-19 Path to Herd Immunity via
Time Series Analysis
3. Dataset available here: https://github.com/owid/covid-19-data/blob/master/public/data/owid-covid-data.csv

# NOTEBOOK INCLUDES
 1. Data Preparation including cleaning and analysis the data
 2. Exploratory data analysis on complete world vaccination data 
 3. Exploration of Prophet 
 5. Adjusting the data as required
 4. Statistical Predictions

#Dynamic data is used for analysis hence the graphs may change depending on latest data received.

# Import Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
import scipy
from matplotlib import dates
from fbprophet import Prophet
import pandas as pd
import matplotlib.pyplot as plt 
import numpy as np
from IPython.display import Javascript
from datetime import datetime
from pandas.api.types import is_numeric_dtype
from google.colab import files
import os
import time
import getpass
import statistics
import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.pylab import rcParams
import statsmodels.api as sm
from pylab import rcParams
rcParams["figure.figsize"] = 12,8

"""## Import geopandas for ploting of world map"""

#import for geomaps
!pip install geopandas

#import geo data from geopandas
import geopandas as gpd

"""# Load the data 
1. Take the latest data(updated on daily basis) in our world in Data github repository
"""

#set variables for loading the 

#load URL
covid_url = 'https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv'
#read the CSV file
covid_data = pd.read_csv(covid_url, error_bad_lines=False)

"""## Shape of data"""

#Shape of data
covid_data.shape

"""##Number of countries in the dataset

Check how many countries are present in the dataset
"""

#Check how many countries are present in the dataset
covid_data['location'].nunique()

#check for all missing values in data
covid_data.isnull().sum()

"""**We see null values in vaccination columns as 70k because vaccination started from around December in various countries and we will only have data from that day**

## Print basic statics of data
"""

# Print basic statics of data
cm = sns.light_palette("red", as_cmap=True)
covid19_stats = covid_data.describe().style.background_gradient(cmap=cm)
display(covid19_stats)

"""**The darkest shade represent maximun number in that particular column. 
If we check new_deaths we can see the count value is more than maximum value for deaths, the count will be the total deaths and max is the maximum new deaths in a day**

#Data Processing

# Exploratory Data Analysis for vaccination rates

## Relation-People fully vaccinated per hundred vs Contient
Plot graph for people fully vaccinated per hundred vs Contient
"""

#use lineplot to plot data 

graph = sns.lineplot(data= covid_data.sort_values(by='date'), x='date', y='people_fully_vaccinated_per_hundred',hue='continent' )
graph.xaxis.set_major_locator(mdates.DayLocator(interval = 15))
#graph.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

plt.xticks(rotation = 90)
plt.gcf().autofmt_xdate()
plt.show()

"""We can see as more and more time passing by various countries are progressing on vaccinated people 


1.   We see a good linear progress in North America Graph
2.   People are hardly vaccinated in Oceania 
3.   Graph for Asia, Europe and North America is more or less close to each other

##Relation-people fully vaccinated per hundred vs life_expectancy

Plot a graph to show the relation between people fully vaccinated per hundred vs life_expectancy
"""

#Plot a graph to show the relation between people fully vaccinated per hundred vs life_expectancy
covid_data['life_expectancy_graph'] = pd.qcut(covid_data['life_expectancy'],q=5)
graph = sns.lineplot(data=covid_data.sort_values(by='date'), x='date', y='people_fully_vaccinated_per_hundred',hue='life_expectancy_graph')
#graph.xaxis.set_major_formatter(mdates.DateFormatter('%d-%m-%Y'))
graph.xaxis.set_major_locator(mdates.DayLocator(interval = 15))
plt.xticks(rotation = 90)
plt.gcf().autofmt_xdate()
plt.show()

"""* We can observe that as people are getting vaccinated life 
expectancy is also linearly increasing 
* Life expectancy is the average time a person lives 
* We can observe that in all cases are time is passing by and people started to get vaccine life expectancy is increasing

##Relation -people fully vaccinated per hundred vs country
Plot a graph to show the relation between people fully vaccinated per hundred vs some of the main countries
"""

graph = sns.lineplot(data=covid_data[covid_data['iso_code'].isin(['GBR','IDN','BRA','RUS','DEU','JPN','IND','USA','CHN'])]
                     .sort_values(by='date'), x='date', y='people_fully_vaccinated_per_hundred',hue='location')
#graph.xaxis.set_major_formatter(mdates.DateFormatter('%d-%m-%Y'))
graph.xaxis.set_major_locator(mdates.DayLocator(interval = 15))
plt.xticks(rotation = 90)
plt.show()

"""Randomly decided on 8 countries and checked the vaccination rate
* For United States the vaccination per hundred is getting increased day by day as we think of the vacinations are going good and there was gradual increase in the vaccination rate
* We can correctly see that Japan started the vaccination around mind February
* We can obsereve that Germany started it's vaccination last year and is following the same average speed hence that graph is linear for Germany

##Overall plot for people_fully_vaccinated_per_hundred 

overall plot for people_fully_vaccinated_per_hundred
"""

#overall plot for people_fully_vaccinated_per_hundred 
graph = sns.lineplot(data=covid_data.sort_values(by="date"), x="date",
                     y="people_fully_vaccinated_per_hundred")
#graph.xaxis.set_major_formatter(mdates.DateFormatter('%d-%m-%Y'))
graph.xaxis.set_major_locator(mdates.DayLocator(interval = 15))
plt.xticks(rotation = 90)
plt.show()

"""We have plotted the overall plot here:
* Overall the number of vaccinated people in the world is increasing day by day and we have a linear increase in graph 
*  Various countries have started rolling our vaccination and gradually increasing there vaccination rate per day

## Map plot based on country map
"""

#we will read in data for plotting map
world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))
world.head(2)

#as we already have continent in our data we will drop that column
del world['continent']
#We will join both the data for covid and world map and join it on iso_code
mapped = world.set_index('iso_a3').join(covid_data.set_index('iso_code')).reset_index()

#function to create map graph
def graph_world(feature):
    #whichever data we wish to map we will send in feature
    to_be_mapped = feature
    vmin, vmax = 0,100
    fig, ax = plt.subplots(1, figsize=(25,25))

    mapped.plot(column=to_be_mapped, cmap='inferno', linewidth=0.8, ax=ax, edgecolors='0.8' , legend=True,
                legend_kwds={'label': "People Fully Vaccinated Per Hundred", 'orientation': "horizontal"})
    ax.set_title('People Fully Vaccinated In the World', fontdict={'fontsize':30})
    ax.set_axis_off()

#we will send data for full vaccinated people per hundred
graph_world('people_fully_vaccinated_per_hundred')

"""Here we have plotted people full vaccinated in the world graph on a World Map
1. Countries like USA, Chile, Alaska have vaccinated majority of there population. 
2. Countries like Russia, Brazil have reached on a little bit higher side hence they are in the Dark Purple.
3. Countires like Canada, India still have less vaccinated people as per population and hence they are in the Dark Black side.

#Prediction of vactionation rate

Find the top five country which are having the maximum vaccination in the world
"""

top_5_vacc = list(covid_data[(~covid_data['people_fully_vaccinated_per_hundred'].isna())&
                            (covid_data['date']=='2021-04-28')].sort_values
                            (by='people_fully_vaccinated_per_hundred',ascending=False)
                            .head(5)['iso_code'])
print("Top 5 vaccinated countries :\n",top_5_vacc)

#Top five countries in the world with highest vaccination rates
graph = sns.lineplot(data=covid_data[covid_data['iso_code'].isin(top_5_vacc)]
                     .sort_values(by="date"), x="date", y="people_fully_vaccinated_per_hundred",hue='location')
graph.xaxis.set_major_formatter(mdates.DateFormatter('%d-%m-%YYYY'))
graph.xaxis.set_major_locator(mdates.DayLocator(interval = 15))
plt.xticks(rotation = 90)

plt.show()

"""This graph shows the top five countries with highest vaccination rate
 1. Seychelles have been termed as the most vaccinated nation on Earth by WHO and we can see the vaccination per hundred is more there
 2. Israel is at the second position with a population of over 90 lakhs which is much more than Seychelles, there was rapid vaccination here and they are covid free
 3. Chile vaccination rollout is one of the best in world and we can see a rapid increase in the vaccination rate unlike USA which is linear

##Predict vaccination Rate for Top five countries

###Function to forecast vaccination and infection rate 

1. Define Prophet Model
2. Fit the model
3. Define the period for which we want a prediction
4. Use the model to make a forecast
5. Summarize the forecast
6. Plot the forecast
"""

def fcast(cntry, isVaccRate):
    if isVaccRate == "true":
      predict_data = covid_data[covid_data['iso_code'].isin([cntry])].sort_values(by="date")[['date',"people_fully_vaccinated_per_hundred"]]
    else :
      predict_data = covid_data[covid_data['iso_code'].isin([cntry])].sort_values(by="date")[['date',"new_cases_per_million"]]
   
    #ds-datestamp y-measure we wish to predict
    predict_data.columns = ['ds', 'y']
    # define the model
    model = Prophet()
    # # fit the model
    model.fit(predict_data)
    # define the period for which we want a prediction
    future = list()
    for i in range(1, 13):
        date = '2021-%01d' % i
        future.append([date])
    for i in range(1, 13):
        date = '2022-%12d' % i
        future.append([date])    
    future = pd.DataFrame(future)
    future.columns = ['ds']
    future['ds']= pd.to_datetime(future['ds'])
    
    # use the model to make a forecast
    forecast = model.predict(future)
    # summarize the forecast
    print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head(5))
    # plot forecast
    
    model.plot(forecast)
    
    if isVaccRate == "true":
      plt.ylim(0, 100)
      n_lower=forecast['yhat_lower'].sub(100).abs().idxmin()
      n_upper=forecast['yhat_upper'].sub(100).abs().idxmin()
    else:
      plt.ylim(0, 2000)

    if isVaccRate == "true":
      plt.title(cntry 
                + ' forecast of people_fully_vaccinated_per_hundred: 100% expected between ' 
                + forecast[n_lower:n_lower+1]['ds'].iloc[0].strftime('%Y-%m-%d') 
                + ' and ' 
                + forecast[n_upper:n_upper+1]['ds'].iloc[0].strftime('%Y-%m-%d'))
    else:
      plt.title(cntry 
                + ' forecast of new_cases_smoothed_per_hundred')
      
    plt.show()

"""#Forecast for vaccination and infection rate for top 5 countries

##Forecast for Seychelles
"""

#Forecast for Seychelles for vaccination rate
fcast('SYC', "true")

"""Prediction for Seychelles
1. Seychelles will be fully vaccinated by July 2021, here not everyone is vaccinated but almost 70% of population is already vaccinated
2. We could see a rapid increase in vaccination in this country, they started around end of 2020


"""

#Forecast for Seychelles for infection rate
fcast('SYC', "false")

"""1. The infection has again increased in this country hence we can see a increase in infection between March and May
2. We can correctly obsereve that infection is going up as there have been a increase in number of cases here

##Forecast For ISRAEL
"""

#Forecast for Israel for vaccination rate
fcast('ISR', "true")

"""1. Prediction for when Israel will get fully vaccinated depending on the current rate Israel will be vaccinated around starting of 2021
2. Israel declared itself fully vaccinated around End of April and we can correctly predict it 
"""

#Forecast for Israel for infection rate
fcast('ISR', "false")

"""1. Depending on the current data we can observe that the prediction is that around May 2021 there will be zero cases in Israel
2. After being fully vaccinated predicted around end of April the cases will go down to zero as we can see in the graph above it went down to zero around May 2021 right after Israel declared itself covid free.

##Forecast For CHL
"""

fcast('CHL', "true")

"""1. Arrounding to prediction Chile will get fully vaccinated around August of 2021 depending on the current vaccination rate Chile is rapidly getting vaccinated """

fcast('CHL', "false")

"""1. Even though the vaccination will happen till October the infection rate have gone down in Chile as most of the population have aready received vaccination 
2. The infections will go down in Noverber according to the dates right after Chile will be fully vaccinated

##Forecast For USA
"""

fcast('USA','true')

"""1. Prediction for when USA will get fully vaccinated depending on the current rate
2. USA will be 100% vaccinated around end of 2021


"""

fcast("USA","false")

"""##Forecast for Bahrain"""

fcast('BHR', "true")

fcast('BHR', "false")

"""#Processing of data for Statistical Analysis

## Preprocess raw data

1. convert the "Date" column into DATETIME data type
2. Remove small location where population is less than 1000000
3. Set 'location' column as row index
4. Re-scale 'total_vaccinations_per_hundred' and 'people_fully_vaccinated_per_hundred' to per million
"""

#check the dates from covid data and store in two different variables
covid_data['date'] = pd.to_datetime(covid_data['date'])
covid_dates = covid_data['date'].to_list()
covid_latest_date = covid_data['date'].to_list()[-1].strftime('%b %d, %Y')

#set a minumum value for population
min_population = 1000000

#have a copy of covid data
preProcessed_covid_df = covid_data.copy()
# convert the "Date" column into DATETIME data type
preProcessed_covid_df['date'] = pd.to_datetime(preProcessed_covid_df['date'])

# Remove small location where population is less than 1000000
preProcessed_covid_df = preProcessed_covid_df[preProcessed_covid_df.population >= min_population]

# Set 'location' column as row index
preProcessed_covid_df.set_index('location', inplace=True)

#Re-scale 'total_vaccinations_per_hundred' and 'people_fully_vaccinated_per_hundred' to per million
preProcessed_covid_df['total_vaccinations_per_hundred'] *= 10000
preProcessed_covid_df['people_fully_vaccinated_per_hundred'] *= 10000
preProcessed_covid_df.rename(columns = {"total_vaccinations_per_hundred":"total_vaccinations_per_million",
                 "people_fully_vaccinated_per_hundred":"people_fully_vaccinated_per_million"}, inplace=True)

"""##Create Dataset to be used

1. Created new columns "perCapita_daily_columns" and "perCapita_cumulative_columns" using the exising column
2. Created dataframes for "covid_perCapita_daily_df" and "covid_perCapita_cumulative_df"

"""

#Create Dataset to be used
#Created new columns "perCapita_daily_columns" and "perCapita_cumulative_columns" using the exising column
perCapita_daily_columns = ["date","new_cases_smoothed_per_million", "new_deaths_smoothed_per_million",
                           "new_vaccinations_smoothed_per_million"]
#here we will have the total columns
perCapita_cumulative_columns = ["date", "total_cases_per_million", "total_deaths_per_million",
                                "total_vaccinations_per_million", "people_fully_vaccinated_per_million"]

# Created dataframes for "covid_perCapita_daily_df" and "covid_perCapita_cumulative_df"
covid_perCapita_daily_df = preProcessed_covid_df[perCapita_daily_columns]
covid_perCapita_cumulative_df = preProcessed_covid_df[perCapita_cumulative_columns]

"""##Plot Cumulative daily vaccination data

1. Define death and vaccination threshold and remove the locations below daily deaths and vacconation threshold
2. Define Tempory datasets: extract current and past date rows for each location
3. Define median vaccination

## Plot graph for CUMULATIVE DAILY DATA
"""

# CUMULATIVE DAILY DATA #
num_days_back = 7
legend_labels = []
x_vals = []
bar_width = 0.2
date_offset = 0
bar_transparency = 1
current_date = covid_dates[-4+date_offset]
past_date = covid_dates[-4*(num_days_back-date_offset)]
cumulative_deaths_threshold = 100 # include locations with more than this per million
cumulative_vax_threshold = 10


# Remove locations below daily deaths and vaccinations thresholds
covid_perCapita_cumulative_filtered_df = covid_perCapita_cumulative_df.query('total_deaths_per_million > %d or total_vaccinations_per_million > %d' %
                                                                 (cumulative_deaths_threshold, cumulative_vax_threshold))
# Temp datasets: extract current and past date rows for each location
temp_current_df = covid_perCapita_cumulative_filtered_df.sort_values('date').groupby('location').apply(lambda x: x[x['date'] == current_date])
temp_past_df = covid_perCapita_cumulative_filtered_df.sort_values('date').groupby('location').apply(lambda x: x[x['date'] == past_date])

# median total vaccinations
median_total_vaxs = int(temp_current_df['total_vaccinations_per_million'].median())

"""##Function to plot the Cumulative data vs  Vacination 
#This function will input the parameter which we have to plot against vaccination and check if it is death parameter or cases parameter
"""

# Commented out IPython magic to ensure Python compatibility.
#function to plot the cumulative data vs  vacination 
#this function will input the parameter which we have to plot against vaccination and if it is death parameter or not
def plotFunction(value_plot, death):


  #sort the data for the parameter for which we are checking
  temp_current_df_sort = temp_current_df.sort_values(value_plot, ascending=False)
  temp_past_df_re = temp_past_df.reindex(temp_current_df_sort.index)

  x_vals = np.arange(len(temp_current_df.index))
  fig, axs = plt.subplots(1, 1, figsize=[int(len(x_vals)/4),10])

  fig.tight_layout(h_pad=10)
  inclusion_string = "Deaths data is available on this date for %d locations with population > %d, and deaths > %d/mil or vaccinations > %d/mil.\n\
      Data source: https://github.com/owid/covid-19-data/blob/master/public/data/owid-covid-data.csv\n\
      Median vaccinations done for these locations to date: %d/mil" \
#       % (len([i[0] for i in temp_current_df.index]), min_population, cumulative_deaths_threshold, cumulative_vax_threshold, median_total_vaxs)


  #set two axis to plot two graphs
  ax_top1 = axs
  ax_top2 = ax_top1.twinx()
  ax_top2.ticklabel_format(scilimits=[0, 10])

  #second graph will hold vaccination data
  ax_top2.set_ylabel('Vaccinations', fontsize=15)
  
  #depending on if we need to plot againt death or cases we will set another garph
  if death == True:
    ax_top1.set_ylabel('Deaths', fontsize=15)
    ax_top1.set_title("Total Vaccinations/Million Compared to Total Deaths/Million: %s" % current_date.strftime('%b %d, %Y'), fontsize=15)
  else:
    ax_top1.set_ylabel('Cases', fontsize=15)
    ax_top1.set_title("Total Vaccinations/Million Compared to Total Cases/Million: %s" % current_date.strftime('%b %d, %Y'), fontsize=15)

  #set the colour and other parameters plot for death we use red color for cases we use darkorange
  ax_top1.set_xticks(x_vals + bar_width*1.3)
  ax_top1.set_xticklabels([i[0] for i in temp_current_df_sort.index], rotation = 45, ha='right')
  ax_top1.set_xlim([-0.5,len(x_vals)])
  
  if death == True:
    ax_top1.bar(x_vals + bar_width*2, temp_past_df_re[value_plot], alpha=bar_transparency, color='lightcoral', width=bar_width, zorder=1)
    ax_top1.bar(x_vals + bar_width*3, temp_current_df_sort[value_plot], alpha=bar_transparency, color='red', width=bar_width, zorder=1)

  else:
    ax_top1.bar(x_vals + bar_width*2, temp_past_df_re[value_plot], alpha=bar_transparency, color='navajowhite', width=bar_width)
    ax_top1.bar(x_vals + bar_width*3, temp_current_df_sort[value_plot], alpha=bar_transparency, color='darkorange', width=bar_width)

  #set vaccination parameter and define a colour for plotting
  ax_top1.hlines(ax_top1.get_yticks()[-1]/2, ax_top1.get_xlim()[0], ax_top1.get_xlim()[1], color='lightgray', zorder=0, linewidth=0.8, label='_nolegend_')
  ax_top2.bar(x_vals, temp_past_df_re["total_vaccinations_per_million"], color='turquoise', width=bar_width, zorder=1)
  ax_top2.bar(x_vals + bar_width, temp_current_df_sort["total_vaccinations_per_million"], alpha=bar_transparency, color='darkcyan', width=bar_width, zorder=1)
  ax_top2.legend(['Total vaccinations %d days prior (smoothed)'%num_days_back, 'Current total vaccinations (smoothed)'], loc=[0.85,0.85])

  #set the past date for which we have plotted 
  if death == True:
    ax_top1.legend(['Total deaths %d days prior (smoothed)'%num_days_back, 'Current total deaths (smoothed)'], loc=[0.867, 0.7])
  else:
    ax_top1.legend(['Total Cases %d days prior (smoothed)'%num_days_back, 'Current total Cases (smoothed)'], loc=[0.867, 0.7])

  ax_top2.text(ax_top2.get_xlim()[1]/2, ax_top2.get_ylim()[1]*0.97, inclusion_string, ha='center', va='top', fontsize=10, zorder=2)

plotFunction("total_deaths_per_million",True)

"""The cumulative data for all locations for Deaths vs Vaccination:
1. Taken the case for Chile the vaccinations rate is high than total deaths by covid also Chile comes under top vaccinated country 
2. For India were the vaccination per million is not yet that hight but still the total deaths is low because overall deaths through Covid 19 is not much in India
3. For Italy were vaccination is not much and we had cases where deaths was highest in Italy
"""

plotFunction("total_cases_per_million", False)

"""The cumulative data for all locations for Cases vs Vaccination:
1. United Arab Emirates have a raid vaccination and the cases are also average here as correctly found from data
2. India saw a rapid increases in Covid cases and we can see that the vaccination total and cases total is almost the same

# Calculate number of weeks to full vaccination

#Function for Calculation of 70% vaccination prediction
"""

#Calculate number of weeks to full vaccination
def weeksToVaccination(location):
    #define few variables 
    #will hold the past dates for which it will check
    last_n_days = 41
    #vaccine threshold i.e.70%
    vaccin_threshold = 0.7
    times_to_vaccin = []
    lowerInterval_vaccin_times = []
    upperInterval_vaccin_times = []
    daily_vaxs = []
    dates = []


    # select relevant vaccination columns for selected location
    location_daily_vaccine_per_mill = preProcessed_covid_df.loc[location, ['new_vaccinations_smoothed_per_million', 'date', 'total_vaccinations_per_million', 
                                                                          'people_fully_vaccinated_per_million']]
    # get date of first daily vaccination value
    first_vax_date = location_daily_vaccine_per_mill.set_index('date').notna().idxmax()
    #only select the data from where the vaccination started
    location_daily_vaccine_per_mill = location_daily_vaccine_per_mill[location_daily_vaccine_per_mill['date'] >= first_vax_date[0]]

    # get times_to_vaccin figures
    for i in range(last_n_days):
    # for last 21 days check if new_vaccinations_smoothed_per_million is more than 0
      if location_daily_vaccine_per_mill.iloc[-1*last_n_days+i]['new_vaccinations_smoothed_per_million'] > 0:
        #take new vaccination in daily figure
        daily_fig = location_daily_vaccine_per_mill.iloc[-1*last_n_days+i]['new_vaccinations_smoothed_per_million']
        #take total vaccination in total fig
        total_fig = location_daily_vaccine_per_mill.iloc[-1*last_n_days+i]['total_vaccinations_per_million']
        #take people fully vaccinated in fully vaccinated fig
        fully_vaxxed_fig = location_daily_vaccine_per_mill.iloc[-1*last_n_days+i]['people_fully_vaccinated_per_million']
        #check if people full vaccinated in null and set to zero
        if math.isnan(fully_vaxxed_fig):
          fully_vaxxed_fig = 0
        #append daily figure value to daily vaccination
        daily_vaxs.append(daily_fig)
        #append the dates 
        dates.append(location_daily_vaccine_per_mill.iloc[-1*last_n_days+i]['date'])
        # append lists for plotting of all this three figure there will be three division here
        times_to_vaccin.append(((vaccin_threshold*1000000 - fully_vaxxed_fig)*2 - (total_fig-2*fully_vaxxed_fig))/(daily_fig*7))
        lowerInterval_vaccin_times.append((((vaccin_threshold-0.2)*1000000 - fully_vaxxed_fig)*2 - (total_fig-2*fully_vaxxed_fig))/(daily_fig*7)) 
        upperInterval_vaccin_times.append((((vaccin_threshold+0.2)*1000000 - fully_vaxxed_fig)*2 - (total_fig-2*fully_vaxxed_fig))/(daily_fig*7))

    # Vaccination breakdowns find the daily dose and people reeciving second dose
    percent_single_dose = (location_daily_vaccine_per_mill['total_vaccinations_per_million'].tail(1) - location_daily_vaccine_per_mill['people_fully_vaccinated_per_million'].tail(1)*2)/10000
    percent_double_dose = location_daily_vaccine_per_mill['people_fully_vaccinated_per_million'].tail(1)/10000

    # plot the findings
    #create a subplot and set valid title
    fig, ax1 = plt.subplots(figsize=(15,10))
    ax1.set_title('%s: Daily vaccinations/million and their times to significant population vaccination\nif they were sustained' % location, fontsize=17, pad=20)
    ax2 = ax1.twinx()
    #ax1 will hold the daily vaccine count 
    # ax1: daily vaxs
    ax1.set_ylabel("Daily\nvaccinations\nper\nmillion", fontsize=15,rotation='horizontal', ha='right', va='center')
    #fill in the color
    ax1.fill_between(dates, daily_vaxs, color='limegreen', alpha=0.5, zorder=-1)
    #set axis limits
    ax1.set_ylim([0, max(daily_vaxs)*1.3])
    ax1.set_xlim([dates[0], dates[-1]])
    ax1.set_xticklabels(ax1.get_xticks(), rotation = 45) 
    ax1.plot(dates,daily_vaxs, color='limegreen',zorder=1)
    ax1.legend(['daily vaccinations per million (smoothed)'], loc='lower left', fontsize=11)
    #ax2 will hold the weeks to be 70% vaccinated
    # ax2: weeks to vaccin
    ax2.plot(dates, times_to_vaccin, color='red', linewidth=4)
    ax2.set_ylim([0, max([x for x in times_to_vaccin if np.isnan(x) == False])*1.1])
    #we plot the upper and lower vaccine time
    ax2.plot(dates, lowerInterval_vaccin_times, color='grey', linewidth=2, linestyle='--')
    ax2.plot(dates, upperInterval_vaccin_times, color='black', linewidth=2, linestyle='--')
    ax2.set_ylabel("Weeks until\n%d%% fully\nvaccinated\n(2 doses)" % int(100*vaccin_threshold), fontsize=15, rotation='horizontal', ha='left', va='center')
    ax2.legend(['weeks to %d%% fully vaccinated if daily number is sustained.' % int(vaccin_threshold*100), 'weeks to %d%% and %d%% vaccinated.' % (int((vaccin_threshold-0.2)*100+1), int((vaccin_threshold+0.2)*100+1))],
              fontsize=11, loc='lower right')
    if not math.isnan(percent_double_dose): 
      ax2.text(dates[int(len(dates)/2)], ax2.get_ylim()[1]*0.97, 'To date: %0.1f%% of population given two doses +\n%0.1f%% given one dose' % (percent_double_dose, percent_single_dose),
            ha='center', va='top', fontsize=14)

"""**Now lets plot graph for United States**"""

weeksToVaccination('United States')

"""We have plotted a Graph for United States we can observe that:
1. The percentage of population who have received full dose and percentage of population who received one dose only
2. It will take 15 weeks for 70% of population to get fully vaccinated according to the current vaccination rate
3. We can also observe the vaccination per day have decreased as we have reached the month of May
2. Almost 50% population has already been vaccinated and or received one dose by 5th. week

**Now lets plot graph for Chile**
"""

weeksToVaccination('Chile')

"""We have plotted a Graph for Chile we can observe that:
1. The percentage of population who have received full dose and percentage of population who received one dose only
2. It will take 12 weeks for 70% of population to get fully vaccinated according to the current vaccination rate
3. We can also observe the vaccination per day have decreased as we have reached the month of May
2. Almost 50% population has already been vaccinated and or received one dose by 3rd week

#Conclusion

We have done COVID-19 predictions beased on Prophet Model and compared it with Statistical Data:
1. USA will be fully vaccinated by end of 2021
2. Thourgh statistical analysis we can predict that USA is currently at week 8 and it will require more 2 months (By August )for 70% vaccination
3. Few more months (August to November )will be required for 100% vaccination at the current rate
4. For Chile the vaccination is taking place rapidly and hence they are only few weeks away from getting 70% vaccinated
5. Through Prohet Model we predicted that Chile will be 100% vaccinated by September.

#Future Steps

* Prophet Model : Prediction was done based on Vaccination rate data however Few countries are still facing uses after vaccinating 70% of the population hence type of vaccine plays a major role.


* Data can be gathered related to different vaccine types used worldwide and predict the effectiveness of that vaccine depending on that we can predict Herd Immunity graph.

#**THANK YOU FOR READING**
"""